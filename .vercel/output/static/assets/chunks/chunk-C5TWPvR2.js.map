{"version":3,"file":"chunk-C5TWPvR2.js","sources":["../../../../../node_modules/@reatom/hooks/build/index.mjs","../../../../../node_modules/@reatom/primitives/build/index.mjs","../../../../../src/components/TLSearchForm.tsx","../../../../../node_modules/@reatom/async/build/index.mjs"],"sourcesContent":["import{action,atom,throwReatomError}from\"@reatom/core\";import{noop,toAbortError}from\"@reatom/utils\";import{abortCauseContext,withAbortableSchedule}from\"@reatom/effects\";const getRootCause=cause=>null===cause.cause?cause:getRootCause(cause.cause),isSameCtx=(ctx1,ctx2)=>getRootCause(ctx1.cause)===getRootCause(ctx2.cause),addOnConnect=(anAtom,cb)=>(anAtom.__reatom.connectHooks??=new Set).add(cb),addOnDisconnect=(anAtom,cb)=>(anAtom.__reatom.disconnectHooks??=new Set).add(cb),addOnUpdate=(anAtom,cb)=>(anAtom.__reatom.updateHooks??=new Set).add(cb),withInit=createState=>anAtom=>{const{initState:initState,isAction:isAction}=anAtom.__reatom;return throwReatomError(isAction,\"action state is not manageable\"),anAtom.__reatom.initState=ctx=>createState(ctx,initState),anAtom},_onConnect=action((ctx,anAtom,fn,controller)=>{ctx.cause.cause=getRootCause(ctx.cause),abortCauseContext.set(ctx.cause,controller);const result=fn(withAbortableSchedule({...ctx,controller:controller,isConnected:()=>isConnected(ctx,anAtom)}));return result instanceof Promise&&controller.signal.addEventListener(\"abort\",()=>result.catch(noop)),result},\"_onConnect\"),onConnect=(anAtom,cb)=>{const connectHook=ctx=>{const controller=new AbortController,cleanup=_onConnect(ctx,anAtom,cb,controller);cleanup instanceof Promise&&cleanup.catch(noop);const cleanupHook=_ctx=>{isSameCtx(ctx,_ctx)&&disconnectHooks.delete(cleanupHook)&&connectHooks.has(connectHook)&&(controller.abort(toAbortError(\"disconnect \"+anAtom.__reatom.name)),\"function\"==typeof cleanup&&cleanup())},disconnectHooks=addOnDisconnect(anAtom,cleanupHook)},connectHooks=addOnConnect(anAtom,connectHook);return()=>connectHooks.delete(connectHook)},onDisconnect=(anAtom,cb)=>onConnect(anAtom,ctx=>()=>cb(ctx)),onUpdate=(anAtom,cb=noop)=>(anAtom.deps??[]).reduce((acc,dep)=>{const un=onUpdate(dep,ctx=>ctx.get(anAtom));return()=>{un(),acc()}},((anAtom,cb=noop)=>{const hook=(ctx,patch)=>{let{state:state}=patch;if(anAtom.__reatom.isAction){if(0===patch.state.length)return;const call=state.at(-1);state=call.payload,patch.params=call.params}cb(ctx,state,patch)},hooks=addOnUpdate(anAtom,hook);return()=>hooks.delete(hook)})(anAtom,cb)),spyChange=(ctx,anAtom,handler)=>{let isChanged=!1;return ctx.spy(anAtom,(newState,prevState)=>{isChanged=!0,handler?.(newState,prevState)}),isChanged},controlConnection=(initState=!0,name)=>anAtom=>{name??=`${anAtom.__reatom.name}.controlConnection`;const isActiveAtom=atom(initState,`${name}._isActiveAtom`);return Object.assign({toggleConnection:action((ctx,value)=>isActiveAtom(ctx,state=>value??!state),`${name}.toggleConnection`)},atom((ctx,state)=>ctx.spy(isActiveAtom)?ctx.spy(anAtom):state,name))},isConnected=(ctx,{__reatom:proto})=>ctx.get(read=>{const cache=proto.patch??read(proto);return!!cache&&cache.subs.size+cache.listeners.size>0}),initializations=atom(null,\"initializations\");initializations.__reatom.initState=()=>new WeakMap;const isInit=ctx=>{const inits=ctx.get(initializations);return inits.has(ctx.cause.proto)?inits.get(ctx.cause.proto)===ctx.cause:(inits.set(ctx.cause.proto,ctx.cause),!0)};export{_onConnect,addOnConnect,addOnDisconnect,addOnUpdate,controlConnection,getRootCause,isConnected,isInit,isSameCtx,onConnect,onDisconnect,onUpdate,spyChange,withInit};\n//# sourceMappingURL=index.mjs.map\n","import { __count, action, atom, isAtom, throwReatomError } from \"@reatom/core\";\nimport { assign, isObject, omit } from \"@reatom/utils\";\n\n//#region src/withAssign.ts\nconst withAssign = (getProps) => (target) => assign(target, getProps(target, target.__reatom.name));\n\n//#endregion\n//#region src/reatomArray.ts\nconst reatomArray = (initState = [], name) => atom(initState, name).pipe(withAssign((target, name$1) => ({\n\t__reatomArray: true,\n\ttoReversed: action((ctx) => target(ctx, (prev) => prev.slice().reverse()), `${name$1}.toReversed`),\n\ttoSorted: action((ctx, compareFn) => target(ctx, (prev) => prev.slice().sort(compareFn)), `${name$1}.toSorted`),\n\ttoSpliced: action((ctx, start, deleteCount, ...items) => target(ctx, (state) => {\n\t\tstate = state.slice();\n\t\tstate.splice(start, deleteCount, ...items);\n\t\treturn state;\n\t}), `${name$1}.toSpliced`),\n\twith: action((ctx, i, value) => target(ctx, (state) => {\n\t\tif (Object.is(state.at(i), value)) return state;\n\t\tstate = state.slice();\n\t\tstate[i] = value;\n\t\treturn state;\n\t}), `${name$1}.with`),\n\tpush: action((ctx, ...items) => {\n\t\tconst arrCopy = ctx.get(target).slice();\n\t\tconst pushed = arrCopy.push(...items);\n\t\ttarget(ctx, arrCopy);\n\t\treturn pushed;\n\t}, `${name$1}.push`),\n\tpop: action((ctx) => {\n\t\tconst arrCopy = ctx.get(target).slice();\n\t\tconst popped = arrCopy.pop();\n\t\ttarget(ctx, arrCopy);\n\t\treturn popped;\n\t}, `${name$1}.pop`),\n\tshift: action((ctx) => {\n\t\tconst arrCopy = ctx.get(target).slice();\n\t\tconst shifted = arrCopy.shift();\n\t\ttarget(ctx, arrCopy);\n\t\treturn shifted;\n\t}, `${name$1}.shift`),\n\tunshift: action((ctx, ...items) => {\n\t\tconst arrCopy = ctx.get(target).slice();\n\t\tconst unshifted = arrCopy.unshift(...items);\n\t\ttarget(ctx, arrCopy);\n\t\treturn unshifted;\n\t}, `${name$1}.unshift`)\n})));\nconst isArrayAtom = (thing) => thing?.__reatomArray === true;\n\n//#endregion\n//#region src/reatomBoolean.ts\nconst reatomBoolean = (init = false, name) => atom(init, name).pipe(withAssign((target, name$1) => ({\n\ttoggle: action((ctx) => target(ctx, (prev) => !prev), `${name$1}.toggle`),\n\tsetTrue: action((ctx) => target(ctx, true), `${name$1}.setTrue`),\n\tsetFalse: action((ctx) => target(ctx, false), `${name$1}.setFalse`),\n\treset: action((ctx) => target(ctx, init), `${name$1}.reset`)\n})));\n\n//#endregion\n//#region src/reatomEnum.ts\nconst reatomEnum = (variants, options = {}) => {\n\tconst { name, format = \"camelCase\", initState = variants[0] } = typeof options === \"string\" ? { name: options } : options;\n\tconst stateAtom = atom(initState, name);\n\tconst enumAtom = Object.assign((ctx, update) => {\n\t\tconst state = stateAtom(ctx, update);\n\t\tthrowReatomError(!variants.includes(state), `invalid enum value \"${state}\" for \"${name}\" enum`);\n\t\treturn state;\n\t}, stateAtom);\n\tconst cases = enumAtom.enum = {};\n\tenumAtom.reset = action((ctx) => enumAtom(ctx, initState), `${name}.reset`);\n\tfor (const variant of variants) {\n\t\tcases[variant] = variant;\n\t\tconst setterName = variant.replace(/^./, (firstLetter) => \"set\" + (format === \"camelCase\" ? firstLetter.toUpperCase() : `_${firstLetter}`));\n\t\tenumAtom[setterName] = action((ctx) => enumAtom(ctx, variant), `${name}.${setterName}`);\n\t}\n\treturn enumAtom;\n};\n\n//#endregion\n//#region src/reatomMap.ts\nconst reatomMap = (initState = new Map(), name) => {\n\tconst atomInitState = initState instanceof Map ? initState : new Map(initState);\n\treturn atom(atomInitState, name).pipe(withAssign((target, name$1) => {\n\t\tconst getOrCreate = action((ctx, key, value) => {\n\t\t\tactions.set(ctx, key, value);\n\t\t\treturn value;\n\t\t}, `${name$1}.getOrCreate`);\n\t\tconst actions = {\n\t\t\tget: (ctx, key) => ctx.get(target).get(key),\n\t\t\tgetOrCreate: (ctx, key, creator) => actions.has(ctx, key) ? actions.get(ctx, key) : getOrCreate(ctx, key, creator()),\n\t\t\thas: (ctx, key) => ctx.get(target).has(key),\n\t\t\tset: action((ctx, key, value) => target(ctx, (prev) => {\n\t\t\t\tconst valuePrev = prev.get(key);\n\t\t\t\treturn Object.is(valuePrev, value) && (value !== undefined || prev.has(key)) ? prev : new Map(prev).set(key, value);\n\t\t\t}), `${name$1}.set`),\n\t\t\tdelete: action((ctx, key) => target(ctx, (prev) => {\n\t\t\t\tif (!prev.has(key)) return prev;\n\t\t\t\tconst next = new Map(prev);\n\t\t\t\tnext.delete(key);\n\t\t\t\treturn next;\n\t\t\t}), `${name$1}.delete`),\n\t\t\tclear: action((ctx) => target(ctx, new Map()), `${name$1}.clear`),\n\t\t\treset: action((ctx) => target(ctx, atomInitState), `${name$1}.reset`),\n\t\t\tsizeAtom: atom((ctx) => ctx.spy(target).size, `${name$1}.size`)\n\t\t};\n\t\treturn actions;\n\t}));\n};\n\n//#endregion\n//#region src/reatomLinkedList.ts\nconst readonly = (anAtom) => ({ ...anAtom });\nconst LL_PREV = Symbol(\"Reatom linked list prev\");\nconst LL_NEXT = Symbol(\"Reatom linked list next\");\nconst addLL = (state, node, after) => {\n\tif (node === after) return;\n\tif (after) {\n\t\tnode[LL_PREV] = after;\n\t\tnode[LL_NEXT] = after[LL_NEXT];\n\t\tafter[LL_NEXT] = node;\n\t\tif (state.tail === after) state.tail = node;\n\t} else {\n\t\tnode[LL_PREV] = null;\n\t\tnode[LL_NEXT] = state.head;\n\t\tif (state.head) state.head[LL_PREV] = node;\n\t\tif (!state.tail) state.tail = node;\n\t\tstate.head = node;\n\t}\n\tstate.size++;\n};\nconst removeLL = (state, node) => {\n\tif (state.head === node) state.head = node[LL_NEXT];\n\telse if (node[LL_PREV] !== null) node[LL_PREV][LL_NEXT] = node[LL_NEXT];\n\tif (state.tail === node) state.tail = node[LL_PREV];\n\telse if (node[LL_NEXT] !== null) node[LL_NEXT][LL_PREV] = node[LL_PREV];\n\tnode[LL_PREV] = null;\n\tnode[LL_NEXT] = null;\n\tstate.size--;\n};\nconst swapLL = (state, a, b) => {\n\tif (a === b) return;\n\tif (state.head === b) return swapLL(state, b, a);\n\tconst prevA = a[LL_PREV];\n\tconst nextA = a[LL_NEXT];\n\tconst prevB = b[LL_PREV];\n\tconst nextB = b[LL_NEXT];\n\tif (nextA === b) {\n\t\ta[LL_NEXT] = nextB;\n\t\tb[LL_PREV] = prevA;\n\t\tb[LL_NEXT] = a;\n\t\ta[LL_PREV] = b;\n\t\tif (nextB) nextB[LL_PREV] = a;\n\t\tif (prevA) prevA[LL_NEXT] = b;\n\t} else if (nextB === a) {\n\t\tb[LL_NEXT] = nextA;\n\t\ta[LL_PREV] = prevB;\n\t\ta[LL_NEXT] = b;\n\t\tb[LL_PREV] = a;\n\t\tif (nextA) nextA[LL_PREV] = b;\n\t\tif (prevB) prevB[LL_NEXT] = a;\n\t} else {\n\t\tif (prevA) prevA[LL_NEXT] = b;\n\t\tif (nextA) nextA[LL_PREV] = b;\n\t\tif (prevB) prevB[LL_NEXT] = a;\n\t\tif (nextB) nextB[LL_PREV] = a;\n\t\ta[LL_PREV] = prevB;\n\t\ta[LL_NEXT] = nextB;\n\t\tb[LL_PREV] = prevA;\n\t\tb[LL_NEXT] = nextA;\n\t}\n\tif (state.head === a) state.head = b;\n\telse if (state.head === b) state.head = a;\n\tif (state.tail === a) state.tail = b;\n\telse if (state.tail === b) state.tail = a;\n};\nconst moveLL = (state, node, after) => {\n\tremoveLL(state, node);\n\taddLL(state, node, after);\n};\nconst clearLL = (state) => {\n\twhile (state.tail) removeLL(state, state.tail);\n};\nconst toArray = (head, prev) => {\n\tlet arr = [];\n\tlet i = 0;\n\twhile (head) {\n\t\tif (prev !== undefined && prev[i] !== head) prev = undefined;\n\t\tarr.push(head);\n\t\thead = head[LL_NEXT];\n\t\ti++;\n\t}\n\treturn arr.length === prev?.length ? prev : arr;\n};\nfunction reatomLinkedList(options, name = __count(\"reatomLinkedList\")) {\n\tconst { create: userCreate = (ctx, ...params) => params[0], key = undefined,...restOptions } = typeof options === \"function\" ? { create: options } : Array.isArray(options) ? {\n\t\tcreate: (ctx, ...params) => params[0],\n\t\tinitState: options\n\t} : options;\n\tconst _name = name;\n\tconst isLL = (node) => !!node && LL_NEXT in node && LL_PREV in node;\n\tconst throwModel = (node) => throwReatomError(isLL(node), \"The data is already in a linked list.\");\n\tconst throwNotModel = (node) => throwReatomError(!isLL(node), \"The passed data is not a linked list node.\");\n\tlet STATE = null;\n\tconst linkedList = atom(STATE, name);\n\tlinkedList.__reatom.initState = (ctx) => {\n\t\ttry {\n\t\t\tif (\"initState\" in restOptions) return createLinkedList(restOptions.initState ?? []);\n\t\t\telse if (\"initSnapshot\" in restOptions) return createLinkedList(ctx, restOptions.initSnapshot ?? []);\n\t\t\telse return createLinkedList([]);\n\t\t} finally {\n\t\t\tSTATE = null;\n\t\t}\n\t};\n\tconst createLinkedList = (ctxOrInitState, initSnapshot) => {\n\t\tconst initState = Array.isArray(ctxOrInitState) ? ctxOrInitState : initSnapshot.map((params) => userCreate(ctxOrInitState, ...params));\n\t\tconst state = {\n\t\t\tsize: 0,\n\t\t\tversion: 1,\n\t\t\tchanges: [],\n\t\t\thead: null,\n\t\t\ttail: null\n\t\t};\n\t\tfor (const node of initState) {\n\t\t\tthrowModel(node);\n\t\t\taddLL(state, node, state.tail);\n\t\t}\n\t\treturn state;\n\t};\n\tconst batchFn = (ctx, cb) => {\n\t\tif (STATE) return cb(ctx);\n\t\tSTATE = linkedList(ctx, ({ head, tail, size, version }) => ({\n\t\t\tsize,\n\t\t\tversion: version + 1,\n\t\t\tchanges: [],\n\t\t\thead,\n\t\t\ttail\n\t\t}));\n\t\ttry {\n\t\t\treturn cb(ctx);\n\t\t} finally {\n\t\t\tSTATE = null;\n\t\t}\n\t};\n\tconst batch = action(batchFn, `${name}._batch`);\n\tconst create = action((ctx, ...params) => {\n\t\treturn batchFn(ctx, () => {\n\t\t\tconst node = userCreate(ctx, ...params);\n\t\t\tthrowReatomError(!isObject(node) && typeof node !== \"function\", `reatomLinkedList can operate only with objects or functions, received \"${node}\".`);\n\t\t\tthrowModel(node);\n\t\t\taddLL(STATE, node, STATE.tail);\n\t\t\tSTATE.changes.push({\n\t\t\t\tkind: \"create\",\n\t\t\t\tnode\n\t\t\t});\n\t\t\treturn node;\n\t\t});\n\t}, `${name}.create`);\n\tconst remove = action((ctx, node) => {\n\t\treturn batchFn(ctx, () => {\n\t\t\tthrowNotModel(node);\n\t\t\tif (node[LL_PREV] === null && node[LL_NEXT] === null && STATE.tail !== node) return false;\n\t\t\tremoveLL(STATE, node);\n\t\t\tSTATE.changes.push({\n\t\t\t\tkind: \"remove\",\n\t\t\t\tnode\n\t\t\t});\n\t\t\treturn true;\n\t\t});\n\t}, `${name}.remove`);\n\tconst swap = action((ctx, a, b) => {\n\t\treturn batchFn(ctx, () => {\n\t\t\tthrowNotModel(a);\n\t\t\tthrowNotModel(b);\n\t\t\tif (a === b) return;\n\t\t\tswapLL(STATE, a, b);\n\t\t\tSTATE.changes.push({\n\t\t\t\tkind: \"swap\",\n\t\t\t\ta,\n\t\t\t\tb\n\t\t\t});\n\t\t});\n\t}, `${name}.swap`);\n\tconst move = action((ctx, node, after) => {\n\t\treturn batchFn(ctx, () => {\n\t\t\tthrowNotModel(node);\n\t\t\tmoveLL(STATE, node, after);\n\t\t\tSTATE.changes.push({\n\t\t\t\tkind: \"move\",\n\t\t\t\tnode,\n\t\t\t\tafter\n\t\t\t});\n\t\t});\n\t}, `${name}.move`);\n\tconst clear = action((ctx) => {\n\t\treturn batchFn(ctx, () => {\n\t\t\tclearLL(STATE);\n\t\t\tSTATE.changes.push({ kind: \"clear\" });\n\t\t});\n\t}, `${name}.clear`);\n\tconst find = (ctx, cb) => {\n\t\tfor (let { head } = ctx.get(linkedList); head; head = head[LL_NEXT]) if (cb(head)) return head;\n\t\treturn null;\n\t};\n\tconst array = atom((ctx, state = []) => toArray(ctx.spy(linkedList).head, state), `${name}.array`);\n\tconst map = key ? atom((ctx) => new Map(\n\t\t// use array as it already memoized and simplifies the order tracking\n\t\tctx.spy(array).map((node) => {\n\t\t\tconst keyValue = node[key];\n\t\t\treturn [isAtom(keyValue) ? ctx.spy(keyValue) : keyValue, node];\n\t\t})\n)) : undefined;\n\tconst reatomMap$1 = (cb, options$1 = {}) => {\n\t\tconst { name: name$1 = __count(`${_name}.reatomMap`),...hooks } = typeof options$1 === \"string\" ? { name: options$1 } : options$1;\n\t\tconst mapList = atom((ctx, mapList$1) => {\n\t\t\tthrowReatomError(STATE, `Can't compute the map of the linked list inside the batching.`);\n\t\t\tconst ll = ctx.spy(linkedList);\n\t\t\tif (!mapList$1 || ll.version - 1 > mapList$1.version) {\n\t\t\t\tif (mapList$1) hooks.onClear?.(ctx, mapList$1);\n\t\t\t\tmapList$1 = {\n\t\t\t\t\tsize: ll.size,\n\t\t\t\t\tversion: ll.version,\n\t\t\t\t\tchanges: [],\n\t\t\t\t\thead: null,\n\t\t\t\t\ttail: null,\n\t\t\t\t\tmap: new WeakMap()\n\t\t\t\t};\n\t\t\t\tfor (let head = ll.head; head; head = head[LL_NEXT]) {\n\t\t\t\t\tconst node = cb(ctx, head);\n\t\t\t\t\taddLL(mapList$1, node, mapList$1.tail);\n\t\t\t\t\tmapList$1.map.set(head, node);\n\t\t\t\t\thooks.onCreate?.(ctx, node);\n\t\t\t\t}\n\t\t\t\tmapList$1.size = ll.size;\n\t\t\t} else {\n\t\t\t\tmapList$1 = {\n\t\t\t\t\thead: mapList$1.head,\n\t\t\t\t\ttail: mapList$1.tail,\n\t\t\t\t\tsize: mapList$1.size,\n\t\t\t\t\tversion: ll.version,\n\t\t\t\t\tchanges: [],\n\t\t\t\t\tmap: mapList$1.map\n\t\t\t\t};\n\t\t\t\tfor (const change of ll.changes) switch (change.kind) {\n\t\t\t\t\tcase \"create\": {\n\t\t\t\t\t\tconst node = cb(ctx, change.node);\n\t\t\t\t\t\taddLL(mapList$1, node, mapList$1.tail);\n\t\t\t\t\t\tmapList$1.map.set(change.node, node);\n\t\t\t\t\t\tmapList$1.changes.push({\n\t\t\t\t\t\t\tkind: \"create\",\n\t\t\t\t\t\t\tnode\n\t\t\t\t\t\t});\n\t\t\t\t\t\thooks.onCreate?.(ctx, node);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"remove\": {\n\t\t\t\t\t\tconst node = mapList$1.map.get(change.node);\n\t\t\t\t\t\tremoveLL(mapList$1, node);\n\t\t\t\t\t\tmapList$1.map.delete(change.node);\n\t\t\t\t\t\tmapList$1.changes.push({\n\t\t\t\t\t\t\tkind: \"remove\",\n\t\t\t\t\t\t\tnode\n\t\t\t\t\t\t});\n\t\t\t\t\t\thooks.onRemove?.(ctx, node, change.node);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"swap\": {\n\t\t\t\t\t\tconst a = mapList$1.map.get(change.a);\n\t\t\t\t\t\tconst b = mapList$1.map.get(change.b);\n\t\t\t\t\t\tswapLL(mapList$1, a, b);\n\t\t\t\t\t\tmapList$1.changes.push({\n\t\t\t\t\t\t\tkind: \"swap\",\n\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\tb\n\t\t\t\t\t\t});\n\t\t\t\t\t\thooks.onSwap?.(ctx, {\n\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\tb\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"move\": {\n\t\t\t\t\t\tconst node = mapList$1.map.get(change.node);\n\t\t\t\t\t\tconst after = change.after ? mapList$1.map.get(change.after) : null;\n\t\t\t\t\t\tmoveLL(mapList$1, node, after);\n\t\t\t\t\t\tmapList$1.changes.push({\n\t\t\t\t\t\t\tkind: \"move\",\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\tafter\n\t\t\t\t\t\t});\n\t\t\t\t\t\thooks.onMove?.(ctx, node);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"clear\": {\n\t\t\t\t\t\thooks.onClear?.(ctx, mapList$1);\n\t\t\t\t\t\tclearLL(mapList$1);\n\t\t\t\t\t\tmapList$1.changes.push({ kind: \"clear\" });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconst kind = change;\n\t\t\t\t\t\tconst error = new Error(`Unhandled linked list change \"${kind}\"`);\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrowReatomError(mapList$1.size !== ll.size, \"Inconsistent linked list, is's a bug, please report an issue\");\n\t\t\treturn mapList$1;\n\t\t}, name$1);\n\t\tconst array$1 = atom((ctx, state = []) => toArray(ctx.spy(mapList).head, state), `${name$1}.array`);\n\t\treturn Object.assign(mapList, {\n\t\t\tarray: array$1,\n\t\t\t__reatomLinkedList: true\n\t\t});\n\t};\n\treturn Object.assign(linkedList, {\n\t\tbatch,\n\t\tcreate,\n\t\tremove,\n\t\tswap,\n\t\tmove,\n\t\tclear,\n\t\tfind,\n\t\tarray,\n\t\tmap,\n\t\tinitiate: createLinkedList,\n\t\treatomMap: reatomMap$1,\n\t\t__reatomLinkedList: true\n\t}).pipe(readonly);\n}\nconst isLinkedListAtom = (thing) => thing?.__reatomLinkedList === true;\n\n//#endregion\n//#region src/reatomNumber.ts\nconst reatomNumber = (initState = 0, name) => atom(initState, name).pipe(withAssign((target, name$1) => ({\n\tincrement: action((ctx, by = 1) => target(ctx, (prev) => prev + by), `${name$1}.increment`),\n\tdecrement: action((ctx, by = 1) => target(ctx, (prev) => prev - by), `${name$1}.decrement`),\n\trandom: action((ctx) => target(ctx, Math.random()), `${name$1}.decrement`),\n\treset: action((ctx) => target(ctx, initState), `${name$1}.reset`)\n})));\n\n//#endregion\n//#region src/reatomRecord.ts\nconst reatomRecord = (initState, name) => atom(initState, name).pipe(withAssign((target) => ({\n\tmerge: action((ctx, slice) => target(ctx, (prev) => {\n\t\tfor (const key in prev) if (!Object.is(prev[key], slice[key])) return {\n\t\t\t...prev,\n\t\t\t...slice\n\t\t};\n\t\treturn prev;\n\t}), `${name}.merge`),\n\tomit: action((ctx, ...keys) => target(ctx, (prev) => {\n\t\tif (keys.some((key) => key in prev)) return omit(prev, keys);\n\t\treturn prev;\n\t}), `${name}.omit`),\n\treset: action((ctx, ...keys) => target(ctx, (prev) => {\n\t\tif (keys.length === 0) return initState;\n\t\tconst next = {};\n\t\tlet changed = false;\n\t\tfor (const key in prev) if (keys.includes(key)) if (key in initState) {\n\t\t\tnext[key] = initState[key];\n\t\t\tchanged ||= !Object.is(prev[key], initState[key]);\n\t\t} else changed ||= key in prev;\n\t\telse next[key] = prev[key];\n\t\treturn changed ? next : prev;\n\t}), `${name}.reset`)\n})));\n\n//#endregion\n//#region src/reatomSet.ts\nconst reatomSet = (initState = new Set(), name) => {\n\tconst atomInitState = initState instanceof Set ? initState : new Set(initState);\n\treturn atom(atomInitState, name).pipe(withAssign((target, name$1) => ({\n\t\t__reatomSet: true,\n\t\tadd: action((ctx, el) => target(ctx, (prev) => prev.has(el) ? prev : new Set(prev).add(el)), `${name$1}.add`),\n\t\tset: action((ctx, el) => target(ctx, (prev) => prev.has(el) ? prev : new Set(prev).add(el)), `${name$1}.set`),\n\t\tdelete: action((ctx, el) => {\n\t\t\treturn target(ctx, (prev) => {\n\t\t\t\tif (!prev.has(el)) return prev;\n\t\t\t\tconst next = new Set(prev);\n\t\t\t\tnext.delete(el);\n\t\t\t\treturn next;\n\t\t\t});\n\t\t}, `${name$1}.delete`),\n\t\tclear: action((ctx) => {\n\t\t\treturn target(ctx, (prev) => {\n\t\t\t\tif (prev.size === 0) return prev;\n\t\t\t\treturn new Set();\n\t\t\t});\n\t\t}, `${name$1}.clear`),\n\t\treset: action((ctx) => target(ctx, atomInitState), `${name$1}.reset`),\n\t\tintersection: action((ctx, set) => target(ctx, (prev) => prev.intersection(set)), `${name$1}.intersection`),\n\t\tunion: action((ctx, set) => target(ctx, (prev) => prev.union(set)), `${name$1}.union`),\n\t\tdifference: action((ctx, set) => target(ctx, (prev) => prev.difference(set)), `${name$1}.difference`),\n\t\tsymmetricDifference: action((ctx, set) => target(ctx, (prev) => prev.symmetricDifference(set)), `${name$1}.symmetricDifference`),\n\t\ttoggle: action((ctx, el) => {\n\t\t\treturn target(ctx, (prev) => {\n\t\t\t\tif (!prev.has(el)) return new Set(prev).add(el);\n\t\t\t\tconst next = new Set(prev);\n\t\t\t\tnext.delete(el);\n\t\t\t\treturn next;\n\t\t\t});\n\t\t}, `${name$1}.toggle`),\n\t\thas: (ctx, el) => ctx.get(target).has(el),\n\t\tisSubsetOf: (ctx, set) => ctx.get(target).isSubsetOf(set),\n\t\tisSupersetOf: (ctx, set) => ctx.get(target).isSupersetOf(set),\n\t\tisDisjointFrom: (ctx, set) => ctx.get(target).isDisjointFrom(set),\n\t\tsize: (ctx) => ctx.get(target).size,\n\t\tsizeAtom: atom((ctx) => ctx.spy(target).size, `${name$1}.size`)\n\t})));\n};\nconst isSetAtom = (thing) => thing?.__reatomSet === true;\n\n//#endregion\n//#region src/reatomString.ts\nconst reatomString = (init = \"\", name) => atom(init, name).pipe(withAssign((target, name$1) => ({ reset: action((ctx) => target(ctx, init), `${name$1}.reset`) })));\n\n//#endregion\n//#region src/withComputed.ts\nconst withComputed = (computed) => (anAtom) => {\n\tconst prevComputed = anAtom.__reatom.computer;\n\tanAtom.__reatom.computer = (ctx, state) => {\n\t\tif (prevComputed) state = prevComputed(ctx, state);\n\t\treturn computed(ctx, state);\n\t};\n\treturn anAtom;\n};\n\n//#endregion\n//#region src/withReducers.ts\nconst withReducers = (reducers) => (anAtom) => Object.keys(reducers).reduce((anAtom$1, k) => {\n\tanAtom$1[k] = action((ctx, ...args) => anAtom$1(ctx, reducers[k](ctx.get(anAtom$1), ...args)), `${anAtom$1.__reatom.name}._${k}`);\n\treturn anAtom$1;\n}, anAtom);\n\n//#endregion\nexport { LL_NEXT, LL_PREV, isArrayAtom, isLinkedListAtom, isSetAtom, reatomArray, reatomBoolean, reatomEnum, reatomLinkedList, reatomMap, reatomNumber, reatomRecord, reatomSet, reatomString, withAssign, withComputed, withReducers };","import { useEffect } from 'react';\r\n\r\nexport const TravelLineSearchForm = ({ id }: { id: string }) => {\r\n  const searchFormUniqueId = `tl-search-form-${id}`;\r\n\r\n  const headScriptBody = (w, q) => {\r\n    var h = [\r\n      'ru-ibe.tlintegration.ru',\r\n      'ibe.tlintegration.ru',\r\n      'ibe.tlintegration.com',\r\n    ];\r\n\r\n    var t = (w.travelline = w.travelline || {}),\r\n      ti = (t.integration = t.integration || {});\r\n    ti.__cq = ti.__cq ? ti.__cq.concat(q) : q;\r\n    if (!ti.__loader) {\r\n      ti.__loader = true;\r\n      var d = w.document,\r\n        c =\r\n          d.getElementsByTagName('head')[0] || d.getElementsByTagName('body')[0];\r\n\r\n      function e(s, f) {\r\n        return function () {\r\n          w.TL || (() => {\r\n            c.removeChild(s);\r\n            f();\r\n          })();\r\n        }\r\n      }\r\n\r\n      (function l(h) {\r\n        if (0 === h.length) return;\r\n        var s = d.createElement('script');\r\n        s.type = 'text/javascript';\r\n        s.async = !0;\r\n        s.src = 'https://' + h[0] + '/integration/loader.js';\r\n        s.onerror = s.onload = e(s, function () {\r\n          l(h.slice(1, h.length));\r\n        });\r\n        c.appendChild(s);\r\n      })(h);\r\n    }\r\n  };\r\n\r\n  const headScript = (w) => {\r\n    const q = [\r\n      ['setContext', 'TL-INT-github_2025-09-16', 'ru'],\r\n      ['embed', 'search-form', { container: searchFormUniqueId }],\r\n    ];\r\n    headScriptBody(w, q);\r\n  };\r\n\r\n  useEffect(() => {\r\n    headScript(window);\r\n  }, []);\r\n\r\n\r\n  const styles = `\r\n    #block-search,\r\n    #block-search * {\r\n      box-sizing: border-box;\r\n    }\r\n    #tl-block-search-wrapper {\r\n    position: relative;\r\n    width: 100%;\r\n    }\r\n    #block-search {\r\n      background: rgba(255, 255, 255, 0.7);\r\n      backdrop-filter: blur(40px);\r\n      max-width: 1040px;\r\n      margin: 0 auto;\r\n      border-radius: 30px;\r\n    }\r\n    #tl-block-search-wrapper:has(#tl-search-form-main) {\r\n      top: 65px;\r\n    }\r\n    #tl-block-search-wrapper:has(#tl-search-form-mobile) {\r\n      padding: 30px 0 0;\r\n    }\r\n    #tl-block-search-wrapper:has(#tl-search-form-detail) {\r\n      padding: 30px 0 0;\r\n    }\r\n    #tl-block-search-wrapper:has(#tl-search-form-inner) {\r\n      padding: 0 0 30px;\r\n    }\r\n    #block-search:has(#tl-search-form-mobile),\r\n    #block-search:has(#tl-search-form-inner),\r\n    #block-search:has(#tl-search-form-detail) {\r\n       background: #d2e0f5;\r\n    }\r\n    #block-search:has(#tl-search-form-inner) {\r\n       max-width: 1376px;\r\n    }\r\n    #block-search:has(#tl-search-form-detail) {\r\n       max-width: 1100px;\r\n    }\r\n    .tl-container {\r\n      padding: 0 25px;\r\n    }\r\n    @media screen and (max-width: 1240px) {\r\n      #tl-block-search-wrapper:has(#tl-search-form-detail) {\r\n        padding: 30px 20px 0;\r\n      }\r\n    }\r\n    @media screen and (min-width: 1221px) {\r\n      #tl-block-search-wrapper:has(#tl-search-form-mobile) {\r\n        display: none;\r\n      }\r\n    }\r\n    @media screen and (max-width: 1220px) {\r\n      #tl-block-search-wrapper:has(#tl-search-form-main) {\r\n        display: none;\r\n      }\r\n\r\n    }\r\n    \r\n    [class*=\"viewing\"],\r\n    [class*=\"viewer\"],\r\n    [class*=\"people\"],\r\n    [class*=\"currently\"],\r\n    [class*=\"просматривают\"],\r\n    [class*=\"человек\"],\r\n    div[style*=\"position: fixed\"][style*=\"bottom\"],\r\n    div[style*=\"position: fixed\"][style*=\"left\"] {\r\n      display: none !important;\r\n      visibility: hidden !important;\r\n    }\r\n    \r\n    .tl-viewing-banner,\r\n    .tl-social-proof,\r\n    .tl-notification,\r\n    [data-tl=\"viewing\"],\r\n    [data-tl=\"notification\"] {\r\n      display: none !important;\r\n    }\r\n  `;\r\n\r\n  return (\r\n    <>\r\n      <style>{styles}</style>\r\n      <div id=\"tl-block-search-wrapper\">\r\n        <div id=\"block-search\">\r\n          <div id={searchFormUniqueId} className=\"tl-container\">\r\n            <a\r\n              href=\"https://www.travelline.ru/products/tl-hotel/\"\r\n              rel=\"nofollow\"\r\n              target=\"_blank\"\r\n            >\r\n              TravelLine\r\n            </a>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n};","import{action,atom,throwReatomError,__count}from\"@reatom/core\";import{__thenReatomed,getTopController,abortCauseContext,spawn,CauseContext,onCtxAbort,withAbortableSchedule}from\"@reatom/effects\";import{onConnect,isConnected}from\"@reatom/hooks\";import{throwIfAborted,toAbortError,assign,isAbort,isDeepEqual,MAX_SAFE_TIMEOUT,setTimeout,isShallowEqual,merge,noop,sleep}from\"@reatom/utils\";import{reatomMap,withAssign}from\"@reatom/primitives\";const handleEffect=(anAsync,params,{shouldPending:shouldPending=!0,shouldFulfill:shouldFulfill=!0,shouldReject:shouldReject=!0,effect:effect=anAsync.__reatom.unstable_fn}={})=>{const pendingAtom=anAsync.pendingAtom,[ctx]=params;shouldPending&&pendingAtom(ctx,s=>++s);const origin=ctx.schedule(()=>new Promise((res,rej)=>{throwIfAborted(ctx.controller),effect(...params).then(res,rej),ctx.controller.signal.addEventListener(\"abort\",()=>rej(toAbortError(ctx.controller.signal.reason)))}));return assign(__thenReatomed(ctx,origin,v=>{shouldFulfill&&anAsync.onFulfill(ctx,v),shouldPending&&pendingAtom(ctx,s=>--s)},e=>{shouldReject&&!isAbort(e)&&anAsync.onReject(ctx,e),shouldPending&&pendingAtom(ctx,s=>--s)}),{controller:ctx.controller})},NOOP_TIMEOUT_ID=-1,withCache=({ignoreAbort:ignoreAbort=!0,length:length=5,paramsLength:paramsLength,staleTime:staleTime=3e5,swr:swrOptions=!0,withPersist:withPersist,paramsToKey:paramsToKey,isEqual:isEqual=(ctx,a,b)=>isDeepEqual(a,b)}={})=>anAsync=>{if(!anAsync.cacheAtom){const swr=!!swrOptions,{shouldPending:shouldPending=!1,shouldFulfill:shouldFulfill=swr,shouldReject:shouldReject=!1}=swrOptions;Infinity!==staleTime&&(staleTime=Math.min(MAX_SAFE_TIMEOUT,staleTime));const find=paramsToKey?(ctx,params,state=ctx.get(cacheAtom))=>{const key=paramsToKey(ctx,params);return{cached:state.get(key),key:key}}:(ctx,params,state=ctx.get(cacheAtom))=>{for(const[key,cached]of state)if(isEqual(ctx,key,params))return{cached:cached,key:key};return{cached:void 0,key:params}},findLatestWithValue=(ctx,state=ctx.get(cacheAtom))=>{for(const cached of state.values())if(cached.version>0&&(!latestCached||cached.lastUpdate>latestCached.lastUpdate))var latestCached=cached;return latestCached},deleteOldest=cache=>{for(const[key,cached]of cache)if(!oldestCached||oldestCached.lastUpdate>cached.lastUpdate)var oldestKey=key,oldestCached=cached;oldestCached&&cache.delete(oldestKey)},planCleanup=(ctx,key,time=staleTime)=>{const clearTimeoutId=Infinity===staleTime?NOOP_TIMEOUT_ID:setTimeout(()=>{cacheAtom.get(ctx,key)?.clearTimeoutId===clearTimeoutId&&cacheAtom.delete(ctx,key)},time);return clearTimeoutId.unref?.(),ctx.schedule(()=>clearTimeout(clearTimeoutId),-1),clearTimeoutId},cacheAtom=anAsync.cacheAtom=reatomMap(new Map,`${anAsync.__reatom.name}._cacheAtom`).pipe(withAssign((target,name)=>({setWithParams:action((ctx,params,value)=>{const{cached:cached,key:key}=find(ctx,params);clearTimeout(cached?.clearTimeoutId),cacheAtom.set(ctx,key,{clearTimeoutId:planCleanup(ctx,key),promise:void 0,value:value,version:cached?cached.version+1:1,controller:new AbortController,lastUpdate:Date.now(),params:params})}),deleteWithParams:action((ctx,params)=>{const{cached:cached,key:key}=find(ctx,params);cached&&cacheAtom.delete(ctx,key)})})));cacheAtom.invalidate=action(ctx=>{const latest=findLatestWithValue(ctx);return cacheAtom.clear(ctx),\"promiseAtom\"in anAsync?anAsync(ctx):latest?anAsync(ctx,...latest.params):null},`${cacheAtom.__reatom.name}.invalidate`),cacheAtom.options={ignoreAbort:ignoreAbort,length:length,paramsLength:paramsLength,staleTime:staleTime,swr:swr,withPersist:withPersist},withPersist&&cacheAtom.pipe(withPersist({key:cacheAtom.__reatom.name,fromSnapshot:(ctx,snapshot,state=new Map)=>{if(snapshot.length<=state?.size&&snapshot.every(([,{params:params,value:value}])=>{const{cached:cached}=find(ctx,params,state);return!!cached&&isDeepEqual(cached.value,value)}))return state;const newState=new Map(snapshot);for(const[key,rec]of newState)staleTime-(Date.now()-rec.lastUpdate)<=0?newState.delete(key):(clearTimeout(rec.clearTimeoutId),rec.clearTimeoutId=planCleanup(ctx,key,staleTime-(Date.now()-rec.lastUpdate)));for(const[key,rec]of state)if(rec.promise){const{cached:cached}=find(ctx,rec.params,newState);cached?cached.promise=rec.promise:newState.set(key,rec)}return newState},time:Math.min(staleTime,MAX_SAFE_TIMEOUT),toSnapshot:(ctx,cache)=>[...cache].filter(([,rec])=>!rec.promise)}));const swrPendingAtom=anAsync.swrPendingAtom=atom(0,`${anAsync.__reatom.name}.swrPendingAtom`),handlePromise=(ctx,key,cached,swr)=>{clearTimeout(cached.clearTimeoutId),cached.clearTimeoutId=planCleanup(ctx,key);const isSame=()=>cacheAtom.get(ctx,key)?.clearTimeoutId===cached.clearTimeoutId,{unstable_fn:unstable_fn}=anAsync.__reatom;let res,rej;return cached.promise=new Promise(function(){return[res,rej]=[].slice.call(arguments)}),function(){try{var a;function _temp2(){return cached.promise}a=[].slice.call(arguments);const _temp=function(body,recover){try{var result=Promise.resolve(ignoreAbort?spawn(a[0],function(ctx){return unstable_fn({...ctx,controller:getTopController(ctx.cause)},...[].slice.call(arguments,1))},a.slice(1)):unstable_fn(...a)).then(function(value){res(value),ctx.get(()=>{isSame()&&cacheAtom.set(ctx,key,{...cached,promise:void 0,value:value,version:cached.version+1}),swr&&swrPendingAtom(ctx,s=>s-1)})})}catch(e){return recover(e)}return result&&result.then?result.then(void 0,recover):result}(0,function(error){rej(error),ctx.get(()=>{isSame()&&(cached.version>0?cacheAtom.set(ctx,key,{...cached,promise:void 0}):cacheAtom.delete(ctx,key)),swr&&swrPendingAtom(ctx,s=>s-1)})});return Promise.resolve(_temp&&_temp.then?_temp.then(_temp2):_temp2())}catch(e){return Promise.reject(e)}}};if(anAsync._handleCache=action(function(){var params=[].slice.call(arguments);const[ctx]=params,controller=getTopController(ctx.cause.cause);abortCauseContext.set(ctx.cause,ctx.controller=controller);const paramsKey=params.slice(1,1+(paramsLength??params.length));let{cached:cached={clearTimeoutId:NOOP_TIMEOUT_ID,promise:void 0,value:void 0,version:0,controller:controller,lastUpdate:-1,params:[]},key:key}=find(ctx,paramsKey);const prevController=cached.controller;cached={...cached,lastUpdate:Date.now(),params:paramsKey,controller:controller};const cache=cacheAtom.set(ctx,key,cached);return cache.size>length&&deleteOldest(cache),0===cached.version&&!cached.promise||cached.promise&&prevController.signal.aborted?handleEffect(anAsync,params,{effect:handlePromise(ctx,key,cached,!1)}):(cached.version>0&&anAsync.onFulfill(ctx,cached.value),cached.promise||!swr?handleEffect(anAsync,params,{effect:function(){try{return Promise.resolve(cached.promise??cached.value)}catch(e){return Promise.reject(e)}},shouldPending:!1,shouldFulfill:shouldFulfill,shouldReject:shouldReject}):(swr&&swrPendingAtom(ctx,s=>s+1),handleEffect(anAsync,params,{effect:handlePromise(ctx,key,cached,swr),shouldPending:shouldPending,shouldFulfill:shouldFulfill,shouldReject:shouldReject})))},`${anAsync.__reatom.name}._handleCache`),\"dataAtom\"in anAsync){const{initState:initState}=anAsync.dataAtom.__reatom;anAsync.dataAtom.__reatom.initState=ctx=>{const cached=findLatestWithValue(ctx),iniState=initState(ctx);return cached?anAsync.dataAtom.mapFulfill?anAsync.dataAtom.mapFulfill(ctx,cached.value,iniState):cached.value:iniState}}withPersist&&\"dataAtom\"in anAsync&&onConnect(anAsync.dataAtom,ctx=>ctx.subscribe(cacheAtom,()=>{}))}return anAsync},memo=reducer=>state=>{const newState=reducer(state);return isShallowEqual(state,newState)?state:newState},asyncStatusesInitState={isPending:!1,isFulfilled:!1,isRejected:!1,isSettled:!1,isFirstPending:!1,isEverPending:!1,isEverSettled:!1},withStatusesAtom=()=>anAsync=>{if(!anAsync.statusesAtom){const relatedPromisesAtom=atom(new WeakSet,`${anAsync.__reatom.name}.statusesAtom._relatedPromisesAtom`),lastSettledStatusAtom=atom(null,`${anAsync.__reatom.name}.statusesAtom._lastSettledStatusAtom`),statusesAtom=atom(asyncStatusesInitState,`${anAsync.__reatom.name}.statusesAtom`);statusesAtom.__reatom.computer=(ctx,state)=>(ctx.spy(anAsync,({payload:payload})=>{ctx.get(relatedPromisesAtom).add(payload);const pending=ctx.get(anAsync.pendingAtom);state=memo(statuses=>({isPending:pending>0,isFulfilled:!1,isRejected:!1,isSettled:!1,isFirstPending:!statuses.isEverPending,isEverPending:!0,isEverSettled:statuses.isEverSettled}))(state)}),state),anAsync.statusesAtom=Object.assign(statusesAtom,{reset:action(ctx=>(relatedPromisesAtom(ctx,new Set),statusesAtom(ctx,asyncStatusesInitState)))}),anAsync.onCall((ctx,payload)=>{ctx.get(statusesAtom),__thenReatomed(ctx,payload,()=>{ctx.get(relatedPromisesAtom).has(payload)&&(statusesAtom(ctx,memo(()=>{const isPending=ctx.get(anAsync.pendingAtom)>0;return{isPending:isPending,isFulfilled:!isPending,isRejected:!1,isSettled:!isPending,isFirstPending:!1,isEverPending:!0,isEverSettled:!0}})),lastSettledStatusAtom(ctx,\"fulfilled\"))},error=>{if(ctx.get(relatedPromisesAtom).has(payload)){const isPending=ctx.get(anAsync.pendingAtom)>0;statusesAtom(ctx,memo(state=>{if(isAbort(error)){const lastSettledStatus=ctx.get(lastSettledStatusAtom);return state.isEverSettled&&!isPending?{isPending:isPending,isFulfilled:\"fulfilled\"===lastSettledStatus,isRejected:\"rejected\"===lastSettledStatus,isSettled:!0,isFirstPending:!1,isEverPending:!0,isEverSettled:!0}:{isPending:isPending,isFulfilled:!1,isRejected:!1,isSettled:!1,isFirstPending:!1,isEverPending:!0,isEverSettled:state.isEverSettled}}return{isPending:isPending,isFulfilled:!1,isRejected:!isPending,isSettled:!isPending,isFirstPending:!1,isEverPending:!0,isEverSettled:!0}})),isAbort(error)||lastSettledStatusAtom(ctx,\"rejected\")}})})}return anAsync},resolved=new WeakSet,reatomResource=(asyncComputed,name=__count(\"asyncAtom\"))=>{const promises=new CauseContext,theAsync=reatomAsync(ctx=>{const promise=promises.get(ctx.cause);return throwReatomError(!promise,\"reaction manual call\"),promise},name),promiseAtom=atom((_ctx,state)=>{if(state&&!_ctx.cause.pubs.length)return state;const params=[],ctx=merge(_ctx,{spy(anAtom,cb){throwReatomError(cb,\"spy reactions are unsupported in ResourceAtom\");const value=_ctx.spy(anAtom);return params.push(value),value}}),abortError=toAbortError(\"concurrent \"+name),controller=new AbortController,unabort=onCtxAbort(ctx,error=>{abortError===error||isConnected(ctx,theReaction)||controller.abort(error)});unabort&&controller.signal.addEventListener(\"abort\",unabort),abortCauseContext.set(ctx.cause,ctx.controller=controller);const computedPromise=asyncComputed(withAbortableSchedule(ctx));computedPromise.catch(noop),promises.set(ctx.cause,computedPromise);const pendingBefore=ctx.get(theAsync.pendingAtom),fulfillCallsBefore=ctx.get(theAsync.onFulfill);let promise=theAsync(ctx,...params);promise.controller.signal.addEventListener(\"abort\",()=>{theReaction.cacheAtom?.options.ignoreAbort||controller.abort(promise.controller.signal.reason)});const cached=pendingBefore===ctx.get(theAsync.pendingAtom),fulfillCalls=ctx.get(theAsync.onFulfill);return cached&&controller.abort(toAbortError(\"cached \"+name)),cached&&fulfillCallsBefore!==fulfillCalls&&(promise=Object.assign(Promise.resolve(fulfillCalls[fulfillCalls.length-1].payload),{controller:controller})),__thenReatomed(ctx,promise,()=>resolved.add(promise),()=>resolved.add(promise)).catch(noop),state?.controller.abort(abortError),promise},`${name}._promiseAtom`);onConnect(theAsync,ctx=>ctx.subscribe(promiseAtom,noop)),onConnect(promiseAtom,ctx=>()=>{ctx.get(read=>{const state=read(promiseAtom.__reatom)?.state;state?.controller.abort(ctx.controller.signal.reason),resolved.has(state)||reset(ctx,promiseAtom.__reatom,ctx.controller.signal.reason)})});const theReaction=Object.assign(ctx=>ctx.get((read,actualize)=>{reset(ctx,promiseAtom.__reatom,toAbortError(\"force \"+name)),actualize(ctx,promiseAtom.__reatom,noop);const state=ctx.get(theAsync),payload=state[state.length-1]?.payload;return throwReatomError(!payload,\"unexpectedly failed invalidation. Please, report the issue\"),payload}),theAsync,{promiseAtom:promiseAtom,init:ctx=>ctx.subscribe(promiseAtom,noop),reset:action(ctx=>{reset(ctx,promiseAtom.__reatom,toAbortError(\"reset \"+name))},`${name}.reset`)});return Object.defineProperty(theAsync,\"_handleCache\",{get:()=>theReaction._handleCache}),theReaction},reset=(ctx,proto,reason)=>ctx.get((read,actualize)=>{if(read(proto)){const{computer:computer}=proto;proto.computer=null;try{actualize(ctx,proto,(patchCtx,patch)=>{patch.state?.controller.abort(reason),patch.pubs=[],patch.state=void 0})}finally{proto.computer=computer}}}),reatomAsyncReaction=reatomResource,isAbortError=isAbort,reatomAsync=(effect,options={})=>{const{name:name=__count(\"async\"),onEffect:onEffectHook,onFulfill:onFulfillHook,onReject:onRejectHook,onSettle:onSettleHook}=\"string\"==typeof options?{name:options}:options,pendingAtom=atom(0,`${name}.pendingAtom`),theAsync=Object.assign(function(){var params=[].slice.call(arguments);return params[0].get((read,actualize)=>{const{state:state}=actualize(params[0],theAsync.__reatom,(ctx,patch)=>{abortCauseContext.set(ctx.cause,ctx.controller=new AbortController);const unabort=onCtxAbort(params[0],error=>{payload?.catch(noop),ctx.controller.abort(error)});unabort&&ctx.controller.signal.addEventListener(\"abort\",unabort),params[0]=withAbortableSchedule(ctx);var payload=theAsync._handleCache?theAsync._handleCache(...params):handleEffect(theAsync,params);__thenReatomed(ctx,payload,void 0,()=>{onReject.__reatom.updateHooks.size>1&&payload.catch(noop)}),patch.state=[...patch.state,{params:params.slice(1),payload:payload}]});return state[state.length-1].payload})},action(effect,name)),onFulfill=action(`${name}.onFulfill`),onReject=action(`${name}.onReject`),onSettle=action(`${name}._onSettle`);return onFulfill.onCall(ctx=>onSettle(ctx)),onReject.onCall(ctx=>onSettle(ctx)),onEffectHook&&theAsync.onCall((ctx,promise,params)=>onEffectHook(ctx,params,promise)),onFulfillHook&&onFulfill.onCall(onFulfillHook),onRejectHook&&onReject.onCall(onRejectHook),onSettleHook&&onSettle.onCall(onSettleHook),onConnect(pendingAtom,ctx=>ctx.subscribe(theAsync,noop)),assign(theAsync,{onFulfill:onFulfill,onReject:onReject,onSettle:onSettle,pendingAtom:pendingAtom})};reatomAsync.from=(effect,options={})=>(effect.name.length>2&&(\"object\"==typeof options?options.name??=effect.name:options??=effect.name),reatomAsync(function(ctx){return effect(...[].slice.call(arguments,1))},options));const withDataAtom=(initState,mapFulfill)=>anAsync=>{if(!anAsync.dataAtom){const dataAtom=anAsync.dataAtom=Object.assign(atom(initState,`${anAsync.__reatom.name}.dataAtom`),{reset:action(ctx=>{dataAtom(ctx,initState)},`${anAsync.__reatom.name}.dataAtom.reset`),mapFulfill:mapFulfill});dataAtom.__reatom.computer=(ctx,state)=>(ctx.spy(anAsync.onFulfill,({payload:payload})=>{state=mapFulfill?mapFulfill(ctx,payload,state):payload}),state),anAsync.onFulfill.onCall(ctx=>{ctx.get(dataAtom)}),onConnect(dataAtom,ctx=>ctx.subscribe(anAsync,noop))}return anAsync},withErrorAtom=(parseError=(ctx,e)=>e instanceof Error?e:new Error(String(e)),{initState:initState,resetTrigger:resetTrigger=\"onEffect\"}={})=>anAsync=>{if(!anAsync.errorAtom){const errorAtomName=`${anAsync.__reatom.name}.errorAtom`,resetTriggerAtom=resetTrigger&&{...anAsync,onEffect:anAsync}[resetTrigger],errorAtom=anAsync.errorAtom=assign(atom(initState,errorAtomName),{reset:action(ctx=>{errorAtom(ctx,initState)},`${errorAtomName}.reset`)});errorAtom.__reatom.computer=(ctx,state)=>(resetTriggerAtom&&ctx.spy(resetTriggerAtom,ctx=>{state=initState}),ctx.spy(anAsync.onReject,({payload:payload})=>{state=parseError(ctx,payload)}),state);const triggers=[anAsync.onReject];resetTriggerAtom&&triggers.push(resetTriggerAtom),triggers.forEach(trigger=>trigger.onChange(ctx=>{ctx.get(errorAtom)}))}return anAsync},withAbort=({strategy:strategy=\"last-in-win\"}={})=>anAsync=>{if(throwReatomError(\"promiseAtom\"in anAsync,'Can\\'t apply \"withAbort\" to \"reatomResource\", it already has its own abort strategy'),!anAsync.abort){const abortControllerAtom=anAsync.abortControllerAtom=atom((ctx,state=new AbortController)=>(ctx.spy(anAsync,({payload:promise})=>{if(\"last-in-win\"===strategy){const controller=state;ctx.schedule(()=>{controller.abort(toAbortError(\"abort (last-in-win) \"+ctx.cause.proto.name))})}if(\"first-in-win\"===strategy&&ctx.get(anAsync.pendingAtom)>1){const error=toAbortError(\"abort (first-in-win)\"+ctx.cause.proto.name);return promise.controller.abort(error),void anAsync.onAbort(ctx,error)}const handleAbort=()=>{anAsync.onAbort(ctx,toAbortError(state.signal.reason))};(state=promise.controller).signal.addEventListener(\"abort\",handleAbort);const removeAbortHandler=()=>state.signal.removeEventListener(\"abort\",handleAbort);__thenReatomed(ctx,promise,removeAbortHandler,removeAbortHandler)}),state),`${anAsync.__reatom.name}._abortControllerAtom`);anAsync.onCall(ctx=>{ctx.get(abortControllerAtom)}),anAsync.abort=action((ctx,reason)=>{const controller=ctx.get(abortControllerAtom);if(controller){const error=toAbortError(reason);ctx.schedule(()=>controller.abort(error))}},`${anAsync.__reatom.name}.abort`),anAsync.onAbort=action(`${anAsync.__reatom.name}.onAbort`)}return anAsync},withRetry=({fallbackParams:fallbackParams,onReject:onReject}={})=>anAsync=>{if(!anAsync.paramsAtom){const paramsAtom=anAsync.paramsAtom=atom(fallbackParams,`${anAsync.__reatom.name}._paramsAtom`);anAsync.onCall((ctx,payload,params)=>paramsAtom(ctx,params)),anAsync.retry=action(function(ctx,after=0){try{function _temp2(_result){const result=anAsync(ctx,...params);return topController?.signal.addEventListener(\"abort\",()=>{controller.abort(topController.signal.reason)}),result}throwReatomError(after<0,\"wrong timeout\");const topController=getTopController(ctx.cause),controller=new AbortController;abortCauseContext.set(ctx.cause,controller);let params=ctx.get(anAsync.paramsAtom);anAsync.promiseAtom&&(params??=[]),throwReatomError(!params,\"no cached params\"),retriesAtom(ctx,s=>s+1);const _temp=function(){if(after>0){const asyncStateInstance=ctx.get(anAsync);return Promise.resolve(sleep(after)).then(function(){const abortReason=topController?.signal.aborted&&topController.signal.reason||asyncStateInstance!==ctx.get(anAsync)&&\"outdated retry\";if(abortReason)throw retriesAtom(ctx,0),toAbortError(abortReason)})}}();return Promise.resolve(_temp&&_temp.then?_temp.then(_temp2):_temp2())}catch(e){return Promise.reject(e)}},`${anAsync.__reatom.name}.retry`);const retriesAtom=anAsync.retriesAtom=atom(0,`${anAsync.__reatom.name}.retriesAtom`);onReject&&anAsync.onCall((ctx,payload)=>{__thenReatomed(ctx,payload,()=>retriesAtom(ctx,0),error=>{const timeout=isAbort(error)?-1:onReject(ctx,error,ctx.get(retriesAtom))??-1;timeout<0?retriesAtom(ctx,0):anAsync.retry(ctx,timeout).catch(noop)})})}return anAsync},withRetryAction=withRetry;function mapToAsync(effect,options={}){return sourceAtom=>{const asyncAction=reatomAsync(effect,{...options,name:options.name??`${sourceAtom.__reatom.name}.mapToAsync`});return asyncAction.unstable_unhook=sourceAtom.onChange(asyncAction),asyncAction}}export{asyncStatusesInitState,isAbortError,mapToAsync,reatomAsync,reatomAsyncReaction,reatomResource,withAbort,withCache,withDataAtom,withErrorAtom,withRetry,withRetryAction,withStatusesAtom};\n//# sourceMappingURL=index.mjs.map\n"],"names":["getRootCause","cause","isSameCtx","ctx1","ctx2","addOnConnect","anAtom","cb","addOnDisconnect","_onConnect","action","ctx","fn","controller","abortCauseContext","result","withAbortableSchedule","isConnected","noop","onConnect","connectHook","cleanup","cleanupHook","_ctx","disconnectHooks","connectHooks","toAbortError","proto","read","cache","initializations","atom","withAssign","getProps","target","assign","reatomMap","initState","name","atomInitState","name$1","getOrCreate","key","value","actions","creator","prev","valuePrev","next","TravelLineSearchForm","id","searchFormUniqueId","headScriptBody","w","q","h","t","ti","e","s","f","c","d","l","headScript","useEffect","jsxs","Fragment","jsx","handleEffect","anAsync","params","shouldPending","shouldFulfill","shouldReject","effect","pendingAtom","origin","res","rej","throwIfAborted","__thenReatomed","v","isAbort","NOOP_TIMEOUT_ID","withCache","ignoreAbort","length","paramsLength","staleTime","swrOptions","withPersist","paramsToKey","isEqual","a","b","isDeepEqual","swr","MAX_SAFE_TIMEOUT","find","state","cacheAtom","cached","findLatestWithValue","latestCached","deleteOldest","oldestCached","oldestKey","planCleanup","time","clearTimeoutId","setTimeout","latest","snapshot","newState","rec","swrPendingAtom","handlePromise","isSame","unstable_fn","_temp2","_temp","body","recover","spawn","getTopController","error","paramsKey","prevController","iniState","memo","reducer","isShallowEqual","asyncStatusesInitState","withStatusesAtom","relatedPromisesAtom","lastSettledStatusAtom","statusesAtom","payload","pending","statuses","isPending","lastSettledStatus","reatomAsync","options","__count","onEffectHook","onFulfillHook","onRejectHook","onSettleHook","theAsync","actualize","patch","unabort","onCtxAbort","onReject","onFulfill","onSettle","promise","withDataAtom","mapFulfill","dataAtom","withErrorAtom","parseError","resetTrigger","errorAtomName","resetTriggerAtom","errorAtom","triggers","trigger"],"mappings":"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","x_google_ignoreList":[0,1,3]}