{"version":3,"file":"chunk-B2FnCi9K.js","sources":["../../../../../node_modules/vike/dist/esm/client/runtime-client-routing/normalizeUrlArgument.js","../../../../../node_modules/vike/dist/esm/client/runtime-client-routing/navigate.js"],"sourcesContent":["export { normalizeUrlArgument };\nimport { assertUsage, isUrl, isUrlRelative } from './utils.js';\nfunction normalizeUrlArgument(url, fnName) {\n    // Succinct error message to save client-side KBs\n    const errMsg = `URL ${url} passed to ${fnName}() is invalid`;\n    assertUsage(isUrl(url), errMsg);\n    if (url.startsWith(location.origin)) {\n        // Use normalizeClientSideUrl() instead?\n        url = url.slice(location.origin.length);\n    }\n    assertUsage(url.startsWith('/') || isUrlRelative(url), \n    // `errMsg` used the original `url` value\n    errMsg);\n    return url;\n}\n","export { navigate };\nexport { reload };\n// import { modifyUrlSameOrigin, ModifyUrlSameOriginOptions } from '../../shared/modifyUrlSameOrigin.js'\nimport { getCurrentUrl } from '../shared/getCurrentUrl.js';\nimport { normalizeUrlArgument } from './normalizeUrlArgument.js';\nimport { firstRenderStartPromise, renderPageClientSide } from './renderPageClientSide.js';\nimport { assertClientRouting } from './utils.js';\nassertClientRouting();\n/** Programmatically navigate to a new page.\n *\n * https://vike.dev/navigate\n *\n * @param url - The URL of the new page.\n * @param keepScrollPosition - Don't scroll to the top of the page, instead keep the current scroll position.\n * @param overwriteLastHistoryEntry - Don't create a new entry in the browser's history, instead let the new URL replace the current URL. (This effectively removes the current URL from the browser history).\n */\nasync function navigate(url, options) {\n    // let url = normalizeUrlArgument(options.url ?? getCurrentUrl(), 'navigate')\n    // url = modifyUrlSameOrigin(url, options)\n    normalizeUrlArgument(url, 'navigate');\n    // If `hydrationCanBeAborted === false` (e.g. Vue) then we can apply navigate() only after hydration is done\n    await firstRenderStartPromise;\n    const { keepScrollPosition, overwriteLastHistoryEntry, pageContext } = options ?? {};\n    const scrollTarget = { preserveScroll: keepScrollPosition ?? false };\n    await renderPageClientSide({\n        scrollTarget,\n        urlOriginal: url,\n        overwriteLastHistoryEntry,\n        isBackwardNavigation: false,\n        pageContextInitClient: pageContext,\n    });\n}\nasync function reload() {\n    await navigate(getCurrentUrl());\n}\n"],"names":["normalizeUrlArgument","url","fnName","errMsg","assertUsage","isUrl","isUrlRelative","assertClientRouting","navigate","options","firstRenderStartPromise","keepScrollPosition","overwriteLastHistoryEntry","pageContext","renderPageClientSide"],"mappings":"4GAEA,SAASA,EAAqBC,EAAKC,EAAQ,CAEvC,MAAMC,EAAS,OAAOF,CAAG,cAAcC,CAAM,gBAC7C,OAAAE,EAAYC,EAAMJ,CAAG,EAAGE,CAAM,EAC1BF,EAAI,WAAW,SAAS,MAAM,IAE9BA,EAAMA,EAAI,MAAM,SAAS,OAAO,MAAM,GAE1CG,EAAYH,EAAI,WAAW,GAAG,GAAKK,EAAcL,CAAG,EAEpDE,CAAM,EACCF,CACX,CCPAM,EAAmB,EASnB,eAAeC,EAASP,EAAKQ,EAAS,CAGlCT,EAAqBC,EAAK,UAAU,EAEpC,MAAMS,EACN,KAAM,CAAE,mBAAAC,EAAoB,0BAAAC,EAA2B,YAAAC,CAAW,EAAgB,CAAA,EAElF,MAAMC,EAAqB,CACvB,aAFiB,CAAE,eAAgBH,GAAsB,EAAK,EAG9D,YAAaV,EACb,0BAAAW,EACA,qBAAsB,GACtB,sBAAuBC,CAC/B,CAAK,CACL","x_google_ignoreList":[0,1]}