{"version":3,"mappings":";yMAyBA,SAASA,GAAiB,CACtB,OAAO,iBAAiB,WAAYC,CAAU,CAClD,CACA,eAAeA,GAAa,CACxBC,EAAkB,cAAc,EAChC,KAAM,CAAE,uBAAAC,EAAwB,SAAAC,EAAU,QAAAC,CAAO,EAAKC,EAAe,EAMrE,GAAKH,EAKD,MAAMI,EAA4BH,EAAUC,CAAO,MAHnD,OAKR,CACA,eAAeE,EAA4BH,EAAUC,EAAS,CAC1D,MAAMG,EAAeH,EAAQ,MAAM,gBAAkB,OAErD,GADyBI,EAAWJ,EAAQ,GAAG,IAAMI,EAAWL,EAAS,GAAG,GAAKC,EAAQ,MAAQD,EAAS,IACpF,CAElBM,EAAkBF,CAAY,EAC9B,MACJ,CAEA,MAAMG,EAD4BN,EAAQ,MAAM,cAAgB,QAAUD,EAAS,MAAM,cAAgB,OAEnGQ,EAAuB,CAACP,EAAQ,MAAM,WAAa,CAACD,EAAS,MAAM,UAAY,KAAOC,EAAQ,MAAM,UAAYD,EAAS,MAAM,UACrI,MAAMS,EAAqB,CAAE,aAAAL,EAAc,qBAAAI,EAAsB,sBAAAD,CAAqB,CAAE,CAC5F,CACA,SAASF,EAAWK,EAAK,CACrB,OAAOA,EAAI,MAAM,GAAG,EAAE,CAAC,CAC3B,CCvDA,SAASC,GAAkB,CACvB,SAAS,iBAAiB,QAASC,CAAW,CAClD,CACA,eAAeA,EAAYC,EAAI,CAC3B,GAAI,CAACC,EAAkBD,CAAE,EACrB,OACJ,MAAME,EAAUC,EAAYH,EAAG,MAAM,EACrC,GAAI,CAACE,EACD,OACJ,MAAME,EAAOF,EAAQ,aAAa,MAAM,EAGxC,GAFIE,IAAS,MAETC,EAAcH,CAAO,EACrB,OAIJ,GAAIE,EAAK,SAAS,GAAG,GAAKE,EAAmBF,CAAI,EAAG,CAEhDJ,EAAG,eAAc,EAEjBO,EAAkBH,EAAK,MAAM,GAAG,EAAE,CAAC,CAAC,EACpC,MACJ,CACA,GAAII,EAASN,CAAO,EAChB,OACJF,EAAG,eAAc,EACjB,IAAIT,EACJ,CACI,MAAMkB,EAAIP,EAAQ,aAAa,sBAAsB,EACjDO,IAAM,OACNlB,EAAe,CAAE,eAAgBkB,IAAM,OAAsB,EACrE,CACA,MAAMb,EAAqB,CACvB,aAAAL,EACA,YAAaa,EACb,qBAAsB,EAC9B,CAAK,CACL,CACA,SAASH,EAAkBD,EAAI,CAC3B,OAAOA,EAAG,SAAW,GAAK,CAACA,EAAG,SAAW,CAACA,EAAG,UAAY,CAACA,EAAG,QAAU,CAACA,EAAG,OAC/E,CACA,SAASG,EAAYO,EAAQ,CACzB,KAAOA,EAAO,UAAY,KAAK,CAC3B,KAAM,CAAE,WAAAC,CAAU,EAAKD,EACvB,GAAI,CAACC,EACD,OAAO,KAEXD,EAASC,CACb,CACA,OAAOD,CACX,CC9CA,eAAeE,GAAmB,CAE9BC,EAAoB,EAEpB,MAAMC,EAAyBC,EAAe,EAE9CjB,EAAe,EAEfkB,EAAwB,EAExB,MAAMF,CACV,CACA,eAAeC,GAAkB,CAC7BE,EAAOC,EAAc,IAAO,CAAC,EAC7B,MAAMtB,EAAqB,CACvB,aAAc,CAAE,eAAgB,EAAI,EACpC,qBAAsB,KACtB,uBAAwB,EAChC,CAAK,CACL,CACA,SAASiB,GAAuB,CAC5BM,EAAsB,EACtBC,IACAC,EAAsB,EAEtBtC,EAAc,CAClB,g9KClCAuC,EAAA,EAOAC,EAAoE,EACpEC,EAAiCC,EAA6B,EAC9Db,EAAA","names":["initOnPopState","onPopState","catchInfiniteLoop","isHistoryStateEnhanced","previous","current","onPopStateBegin","handleBackForwardNavigation","scrollTarget","removeHash","setScrollPosition","doNotRenderIfSamePage","isBackwardNavigation","renderPageClientSide","url","initOnLinkClick","onLinkClick","ev","isNormalLeftClick","linkTag","findLinkTag","href","isLinkIgnored","isSameAsCurrentUrl","scrollToHashOrTop","skipLink","v","target","parentNode","initClientRouter","initHistoryAndScroll","renderFirstPagePromise","renderFirstPage","initLinkPrefetchHandlers","assert","getRenderCount","scrollRestoration_init","initHistory","autoSaveScrollPosition","assertClientRouting","assertSingleInstance_onClientEntryClientRouting","setVirtualFileExportsGlobalEntry","virtualFileExportsGlobalEntry"],"ignoreList":[0,1,2,3],"sources":["../../../../../node_modules/vike/dist/esm/client/runtime-client-routing/initOnPopState.js","../../../../../node_modules/vike/dist/esm/client/runtime-client-routing/initOnLinkClick.js","../../../../../node_modules/vike/dist/esm/client/runtime-client-routing/initClientRouter.js","../../../../../node_modules/vike/dist/esm/client/runtime-client-routing/entry.js"],"sourcesContent":["export { initOnPopState };\nimport { onPopStateBegin } from './history.js';\nimport { renderPageClientSide } from './renderPageClientSide.js';\nimport { setScrollPosition } from './setScrollPosition.js';\nimport { catchInfiniteLoop } from './utils.js';\n// The 'popstate' event is triggered when the browser doesn't fully load the new URL, for example:\n// - `location.hash='#foo'` triggers the popstate event while `location.href='/foo'` doesn't.\n// - Clicking on the browser's back-/forward button triggers a popstate event only if the history entry was generated with history.pushState() â€” no popstate event is fired upon Server Routing.\n// Concretely, 'popstate' is fired when:\n// 1. Back-/forward navigation:\n//    - By the user using the browser's back-/forward navigation\n//    - By the app using `history.back()` / `history.forward()` / `history.go()`\n//    > Except of history entries triggered by Server Routing, see comment above.\n// 2. URL hash changes:\n//    - By the user clicking on `<a href=\"#some-hash\">`\n//      - The popstate event is *only* triggered if `href` starts with '#' (even if `href==='/foo#bar'` and the current URL has the same pathname '/foo' then popstate isn't triggered)\n//      - Vike doesn't intercept hash links (see `skipLink()`) and let's the browser handle them.\n//    - By the app using a `location` API such as `location.hash = 'some-hash'`\n//      - Only upon hash navigation: setting `location.href='/foo'` triggers a full page reload and no popstate event is fired.\n//      - Also upon `location.href='/foo#bar'` while the current URL is '/foo' (unlike <a> clicks).\n// Notes:\n// - The 'hashchange' event is fired after popstate, so we cannot use it to distinguish between hash and non-hash navigations.\n// - It isn't possible to monkey patch the `location` APIs. (Chrome throws `TypeError: Cannot redefine property` when attempt to overwrite any `location` property.)\n// - Text links aren't supported: https://github.com/vikejs/vike/issues/2114\n// - docs/ is a good playground to test all this.\nfunction initOnPopState() {\n    window.addEventListener('popstate', onPopState);\n}\nasync function onPopState() {\n    catchInfiniteLoop('onPopState()');\n    const { isHistoryStateEnhanced, previous, current } = onPopStateBegin();\n    // - `isHistoryStateEnhanced===false` <=> new hash navigation:\n    //   - Click on `<a href=\"#some-hash\">`\n    //   - Using the `location` API (only hash navigation, see comments above).\n    // - `isHistoryStateEnhanced===true` <=> back-/forward navigation (including back-/forward hash navigation).\n    //   > Only back-/forward client-side navigation: no 'popstate' event is fired upon Server Routing (when the user clicks on a link before the page's JavaScript loaded), see comments above.\n    if (!isHistoryStateEnhanced) {\n        // Let the browser handle it\n        return;\n    }\n    else {\n        await handleBackForwardNavigation(previous, current);\n    }\n}\nasync function handleBackForwardNavigation(previous, current) {\n    const scrollTarget = current.state.scrollPosition || undefined;\n    const isHashNavigation = removeHash(current.url) === removeHash(previous.url) && current.url !== previous.url;\n    if (isHashNavigation) {\n        // We have to scroll ourselves because we have set `window.history.scrollRestoration = 'manual'`\n        setScrollPosition(scrollTarget);\n        return;\n    }\n    const isUserPushStateNavigation = current.state.triggeredBy === 'user' || previous.state.triggeredBy === 'user';\n    const doNotRenderIfSamePage = isUserPushStateNavigation;\n    const isBackwardNavigation = !current.state.timestamp || !previous.state.timestamp ? null : current.state.timestamp < previous.state.timestamp;\n    await renderPageClientSide({ scrollTarget, isBackwardNavigation, doNotRenderIfSamePage });\n}\nfunction removeHash(url) {\n    return url.split('#')[0];\n}\n","export { initOnLinkClick };\nimport { isLinkIgnored, isSameAsCurrentUrl, skipLink } from './skipLink.js';\nimport { renderPageClientSide } from './renderPageClientSide.js';\nimport { scrollToHashOrTop } from './setScrollPosition.js';\nfunction initOnLinkClick() {\n    document.addEventListener('click', onLinkClick);\n}\nasync function onLinkClick(ev) {\n    if (!isNormalLeftClick(ev))\n        return;\n    const linkTag = findLinkTag(ev.target);\n    if (!linkTag)\n        return;\n    const href = linkTag.getAttribute('href');\n    if (href === null)\n        return;\n    if (isLinkIgnored(linkTag))\n        return;\n    // Workaround for Firefox bug: clicking on a hash link that doesn't change the current URL causes Firefox to erroneously set `window.history.state = null` without firing any signal that we can detect.\n    // - https://github.com/vikejs/vike/issues/1962\n    // - https://github.com/sveltejs/kit/issues/8725\n    if (href.includes('#') && isSameAsCurrentUrl(href)) {\n        // Prevent Firefox from setting `window.history.state` to `null`\n        ev.preventDefault();\n        // Replicate the browser's native behavior\n        scrollToHashOrTop(href.split('#')[1]);\n        return;\n    }\n    if (skipLink(linkTag))\n        return;\n    ev.preventDefault();\n    let scrollTarget;\n    {\n        const v = linkTag.getAttribute('keep-scroll-position');\n        if (v !== null)\n            scrollTarget = { preserveScroll: v === 'false' ? false : true };\n    }\n    await renderPageClientSide({\n        scrollTarget,\n        urlOriginal: href,\n        isBackwardNavigation: false,\n    });\n}\nfunction isNormalLeftClick(ev) {\n    return ev.button === 0 && !ev.ctrlKey && !ev.shiftKey && !ev.altKey && !ev.metaKey;\n}\nfunction findLinkTag(target) {\n    while (target.tagName !== 'A') {\n        const { parentNode } = target;\n        if (!parentNode) {\n            return null;\n        }\n        target = parentNode;\n    }\n    return target;\n}\n","export { initClientRouter };\nimport { assert } from './utils.js';\nimport { getRenderCount, renderPageClientSide } from './renderPageClientSide.js';\nimport { initOnPopState } from './initOnPopState.js';\nimport { initOnLinkClick } from './initOnLinkClick.js';\nimport { scrollRestoration_init } from './scrollRestoration.js';\nimport { autoSaveScrollPosition } from './setScrollPosition.js';\nimport { initLinkPrefetchHandlers } from './prefetch.js';\nimport { initHistory } from './history.js';\nasync function initClientRouter() {\n    // Init navigation history and scroll restoration\n    initHistoryAndScroll();\n    // Render/hydrate\n    const renderFirstPagePromise = renderFirstPage();\n    // Intercept <a> clicks\n    initOnLinkClick();\n    // Add <a> prefetch handlers\n    initLinkPrefetchHandlers();\n    // Preserve stack track\n    await renderFirstPagePromise;\n}\nasync function renderFirstPage() {\n    assert(getRenderCount() === 0);\n    await renderPageClientSide({\n        scrollTarget: { preserveScroll: true },\n        isBackwardNavigation: null,\n        isClientSideNavigation: false,\n    });\n}\nfunction initHistoryAndScroll() {\n    scrollRestoration_init();\n    initHistory(); // we redundantly call initHistory() to ensure it's called early\n    autoSaveScrollPosition();\n    // Handle back-/forward navigation\n    initOnPopState();\n}\n","import { assertClientRouting } from '../../utils/assertRoutingType.js';\nassertClientRouting();\nimport { initClientRouter } from './initClientRouter.js';\nimport { assertSingleInstance_onClientEntryClientRouting } from './utils.js';\nimport { removeFoucBuster } from '../shared/removeFoucBuster.js';\nimport { setVirtualFileExportsGlobalEntry } from '../shared/getGlobalContextClientInternalShared.js';\n// @ts-expect-error\nimport * as virtualFileExportsGlobalEntry from 'virtual:vike:global-entry:client:client-routing';\nassertSingleInstance_onClientEntryClientRouting(import.meta.env.PROD);\nsetVirtualFileExportsGlobalEntry(virtualFileExportsGlobalEntry);\ninitClientRouter();\nif (import.meta.env.DEV)\n    removeFoucBuster();\n"],"file":"entry-client-routing.F3vxs1Pt.js"}